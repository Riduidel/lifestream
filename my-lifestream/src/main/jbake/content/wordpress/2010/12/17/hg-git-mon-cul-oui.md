type: post
status: published
title: hg , git , mon cul, oui !
tags: dvcs, maven, web
date: Fri Dec 17 14:08:00 CET 2010
~~~~~~
# hg , git , mon cul, oui !

La semaine dernière, j'ai voulu expérimenter une idée que j'ai depuis un moment : exporter les logs de SVN dans un fichier lisible par [Gephi](http://gephi.org/) sous forme d'un [graphe](http://fr.wikipedia.org/wiki/Th&eacute;orie_des_graphes)[dynamique](http://gephi.org/gephi-dynamic-features/), c'est-à-dire un graphe dont les noeuds, et les arcs, changent au cours du temps.Cette idée n'est évidement pas nouvelle, pusique c'est la racine du script [Gource](http://code.google.com/p/gource/). Ce que je voulais (présomptupeusement peut-être) amener, c'est la possibilité de ne pas simplement consulter l'évolution de ce graphe, mais aussi interragir avec lui pour, par exemple, isoler des [clusters](http://fr.wikipedia.org/wiki/Cluster), c'est-à-dire des groupes de fichiers modifiés en même temps, et donc ayant de fortes chances d'être [corrélées](http://fr.wikipedia.org/wiki/Corr&eacute;lation). Tous les javaistes me répondront que c'est facile de trouver des classes conceptuellement proches, grâce à des outils d'analyse de code comme [JDepend](http://www.clarkware.com/software/JDepend.html).Oui, mais là, en l'occurence, ça n'est pas du Java. Ni du Ruby/Groovy/Python/... Ni aucun langage publiquement connu, [en fait](http://www.google.fr/search?client=opera&rls=fr&q=adml+perigee&sourceid=opera&ie=utf-8&oe=utf-8&channel=suggest). Donc, il est "théoriquement" impossible, sans outil d'analyse de ce type, de connaître les liens entre fichiers.Mon hypothèse était donc d'imaginer que, si deux fichiers sont commités simultanément, alors ils ont un lien. Et Gephi, grâce à [ses outils de layout de graphe](http://gephi.org/features/) (je vous aurais bien mis un lien vers une liste des layouts disponibles, mais je n'en ai pas trouvé) peut me permettre de voir ces liens.Il me restait donc à retrousser mes manches pour récupérer la liste des commits SVN avec les fichiers associés, pour les injecter dans Gephi. Pour ça, j'avais évidement besoin de deux composants :
1. Un outil de lecture des commits SVN (coup de bol, ça existe, c'est utilisé dans Eclipse, et le plus facile à intégrer dans du code s'appelle [SVNKit](http://svnkit.com/))
2. Un outil d'écriture des fichiers [GEXF](http://gexf.net/format/) (les fichiers contenant les graphes de Gephi) en Java). Et là, ça se corse.Et on arrive au point qui donne son titre à ce mail.Dans mes flux (ou dans Twitter, je ne sais plus), j'avais vu qu'un type [lisait le contenu d'une base Oracle pour le mettre dans Gephi](http://www.devjason.com/2010/11/22/using-gephi-for-rdb-schema-visualization/) avec ... du Groovy ! Pas con, hein, parce que Groovy est parfaitement et totallement adapté à ce genre de tâches.N'écoutant que mon courage, j'ai donc regardé comment il faisait. Simple, avec une librairie, [gexf4j](http://gexf.net/gexf4j/), qui permet précisément de mapper un fichier GEXF vers des classes Java dédiées (et donc, potentiellement, bien fichues). Issu du monde le plus Java, je me suis logiquement dit que cette librairie, compilée avec Maven et Open-source, devait être disponible sur un quelconque repository. Las, [mvnbrowser](http://mvnbrowser.com/artifacts-search.html?page=1&search=gexf4j) et [jarvana](http://www.jarvana.com/jarvana/search?search_type=project&project=gexf4j) m'ont tous deux donné la même réponse : nada. Du coup, je me suis dit "pas de problème, je télécharge le jar, je l'installe dans mon repository local, et un coup de [](http://groovy.codehaus.org/Grape) suffira ! Seulement si vous regardez bien le site de cette bibliothèque (qui en fait, doit déja être implémentée, sous une forme ou une autre, dans Gephi, qui est **complètement** codé en Java/Swing), vous pourrez lire cette phrase :



> Only sources in GZIP are available for unstable versions.

Je vous demande pardon ? Donc il n'y a pas de version stable, et je ne peux télécharger que le source de la version instable ? euh ... c'est pas un peu cavalier ça ?Les choses empirent : en cliquant sur le lien, vous verrez qu'il vous envoie sur [GitHub](https://github.com/jmcampanini/gexf4j-core/). Donc en fait, il n'y a **pas** de zip des sources. Il faut en fait cloner le dépôt en l'état (bugs included), et compiler chez soi.Passé le premier moment d'incompréhension, je me suis dit "bon, ok, c'est un petit jeune plein de fougue qui veut pas s'emmerder avec du packaging consomateur de temps. Pourquoi pas". Je me suis alors fait la proposition très maligne de faire ce que [je dis](http://riduidel.posterous.com/pourquoi-jai-un-a-priori-contre-git), et d'utiliser [mercurial](http://mercurial.selenic.com/) (déja installé sur mon poste avec [TortoiseHG](http://tortoisehg.bitbucket.org/)) et [hg-git](http://hg-git.github.com/). Bon, l'installation de [hg-git dans TortoiseHG](http://kb.wowace.com/repositories/tortoise-hg-as-a-git-client/) n'est pas immédiate, mais ça marche. J'ai donc cloné le repository, et lancé un brave

<span style="font-family:courier new, monospace;">mvn install</span>

Las ! les classes de test n'étaient pas à jour !Enervé par tout ça, plutôt que de les corriger et de les envoyer à l'auteur, je les ai viré, et ça a marché. C'est alors que j'ai compris que l'auteur n'était en fait pas juste un jeune foufou, mais surtout une grosse feignasse : quand on commite alors que ça ne compile pas, on ne mérite pas d'être utilisé.Bon, comme j'étais dedans jusqu'au coup, j'ai quand même utilisé sa librairie, mais le pire, c'est qu'elle est pleine de bugs !Franchement, j'aurais mieux fait (et je vais peut-être finir par faire) un [Builder Groovy](http://groovy.codehaus.org/Builders) pour Gephi, ça m'aurait évité bien des ennuis.Parce que du coup, mon graphe, que j'espérais dynamique (et donc jouable comme un film Gource) ne l'est en fait pas du tout. Et ça, c'est vexant.

Et là, vous allez me demander pourquoi je m'énerve contre les DVCS.Laissez-moi vous expliquer.Avant, il y avait SVN et les forges. Si je voulais le source, c'était un peu compliqué.Maintenant, avec hg et git (et surtout [BitBucket ](https://bitbucket.org/)et [GitHub](https://github.com/)), c'est devenu hype de mettre son code sur le web et de laisser les gens cloner les dépôts; Du coup, les petits jeunes pleins d'envie psisent trois lignes de codes qui compilent à peu près, les mettent sur GitHub, et s'attendent à ce que l'utilisateur fasse tout l'effort pour que ça marche. Et bien je ne suis pas d'accord. Pour moi, la force de l'open-sourc, c'est le "[release early, release often](http://www.catb.org/~esr/writings/cathedral-bazaar/cathedral-bazaar/ar01s04.html)" dans lequel
on entend deux fois release, e[](36666973#)t pas pour rien, à mon avis; releaser du code, c'est un acte fort : c'est dire aux gens qu'ils peuvent l'utiliser. Là, avec GitHub, j'ai l'impression qu'on se dirige de plus en plus vers un mode de fonctionnement où les gens crachent trois lignes et demi, et s'attendent à ce que les utilisateurs fassent à leur place le boulot d'industrialisation. C'est pas vraiment respectueux, je trouve.