type: post
status: published
title: Java EE 6 et Glassfish 3, Par Antonio Goncalves
tags: java, lecture
date: Fri Jan 07 14:32:00 CET 2011
~~~~~~
# Java EE 6 et Glassfish 3, Par Antonio Goncalves

D'habitude, je ne parle pas de livres sur ce blog-ci (mais plutôt chez [Goodreads](http://www.goodreads.com/riduidel)).Cela dit, d'habitude, je ne parle pas de livres traitant de Java(EE). Mais, dans la mesure où je vais prochainement recommencer à faire du JavaEE, je me suis dit (et mon chef avec moi) que ce serait bien de refraîchir des souvenris vieux de quatre ou cinq ans (et parfois bien incomplets, en particulier en ce qui concerne les EJB). Mon entreprise a donc acheté [Java EE 6 et Glassfish 3](http://www.pearson.fr/livre/?GCOI=27440100553700) par [Antonio Goncalves](http://www.antoniogoncalves.org/xwiki/bin/view/Main/WebHome), [récement](http://agoncal.wordpress.com/2010/06/18/java-ee-6-excuse-my-french/) traduit en français (les traducteurs ont pas du dormir plus que l'auteur, d'ailleurs).Bon, JavaEE, je connais un peu, depuis de précédentes aventures qui m'avaient amené, à leur summum, à offrir [un petit coup de main](http://www.amazon.fr/Cahiers-programmeur-Java-conception-d&eacute;ploiement/dp/2212111940/ref=sr_1_2?s=books&ie=UTF8&qid=1294393369&sr=1-2) à [Jérôme Molière](http://romjethoughts.blogspot.com/).Et puis ayant été [bercé](http://lescastcodeurs.com/) depuis quelques années déja par la voix d'Antonio, je me suis dit, vu la pédagogie qu'il met dans ses interventions orales, qu'il ne pouvait pas être un mauvais auteur ...Et j'avais bien raison. C'est certes un livre épais (553 pages), mais je crois qu'il l'est moins que la norme. En parlant de livre épais, détaillons un peu son contenu :


1.  Tour d'horizon de Java EE 6 : présente rapidement la norme, et surtout son évolution depuis ses toutes premières versions. On y installe également [Glassfish](http://glassfish.java.net/), qui nous accompagnera tout au long du livre
2. Persistance en Java : les chapitres 2 à 5 traitent de JPA 2. C'est, en quelque sorte, une version sous forme d'annotation, et améliorée sur bien des aspects, de ce que j'ai pu voir il y a déja un bon moment avec [Hibernate 3](http://www.hibernate.org/). La plus grande surprise dans cette partie, c'est clairement le fait que la configuration soit d'une simplicité effarante, surtout avec les mécanismes de création de base/table automatique.
3. ORM : Object-Relational Mapping : décrit précisément les différentes stratégies de mapping : one2one, one2many, many2many, tout cet enfer, quoi (sans parler du mapping de classes héritant de classes non persistées ou de classes persistées - ce qui doit être à la fois très pratique et totallement diabolique).
4. Gestion des objets persistants : s'intéresse plus aux différentes requêtes, et au [JPQL](http://en.wikipedia.org/wiki/Java_Persistence_Query_Language). Bon, j'ai personnellement un avis très tranché sur le fait d'écrire des requêtes sous forme de texte non vérifié dans une application écrite dans un langage compilé (et très bien vérifié), cela dit, la norme, c'est la norme. Mais d'un autre côté, je me verrais bien écrire enfin ce gaedo-jpa pour utiliser [toute](http://gaedo.origo.ethz.ch/blog/%5Buser-raw%5D/compilable_queries_a_senseless_concept)[la magie](http://gaedo.origo.ethz.ch/blog/%5Buser-raw%5D/dynamic_finders_the_reference) de gaedo dans ce contexte :-)
5. Méthodes de rappel et écouteurs : un nom curieux pour les callbacks et listeners
6. Entreprise Java Beans ; LE choc. Il y a quatre ou cinq ans, les EJBs, c'était l'enfer de [xdoclet](http://xdoclet.sourceforge.net/xdoclet/index.html). Heureusement, Java5 est passé par là. Et maintenant, un EJB, c'est à mon sens bien plus pratique que, disons, un bean instancié dans Spring. Parce que l'EJB, lui, n'utilise pas vraiment des tonnes de XML (oui, je sais, Spring se passe maintenant assez bien de XML, cela dit, il en faut toujours).
7. Beans de session et service timer : détaille les différentes stratégies d'instanciation des [EJBs](http://en.wikipedia.org/wiki/Ejb) (stateless, stateful, CMC, BMC, ...). Très intéressant, surtout la partie effleurant le sujet qui me paraît incroyablement chouette des EJBs visibles en tant qu'endpoints de web-servcies REST. Et bioen sûr, la second partie du chapitre sur l'utilisation des Timer et TimerService pour créer des tâches planifies est très intéressante ... voire même séduisante...
8. Méthodes de rappel et intercepteurs : détaille les différents callbacks disponibles (@PostConstruct, @Predestroy, et toutes les subtilités relatives à la passivation) pour les EJBs. j'en sens pour l'instant moins l'intérêt, mais ça viendra, je pense. En revanche, la partie sur les intercepteurs ouvre, comme toujours avec l'[AOP](http://fr.wikipedia.org/wiki/Programmation_orient&eacute;e_aspect) sous quelque forme que ce soit, la porte à toutes les folies. Il y a quand même une subtilité curieuse là-dedans : les intercepteurs "standard" utilisent @AroundInvoke quand les intercepteurs du cycle de vie des EJBs utilisent les mêmes annotations que celles utilisées pour les callbacks, mais avec une signature de méthode différente. Ca sent la belle merdasse (enfin, c'est la nrome, hein, pas le bouquin). Cela dit, ce sont des fonctionnalités puissantes. Très puissantes. Trop ? on verra à l'usage, j'imagine ...
9. Transactions et sécurité : Ah, un chapitre que j'attendais aussi pas mal. La partie sur les transactions donne naturellement un léger mal de crâne (surtout la phrase "[Le traitement des exceptions en Java] utilise la notion d'exception contrôlée non contrôlée" p. 294) en évoquant les mystères des transactions rollbackées selon des conditions ... paramétrables (c'est vrai que c'est plus simple pour les EJB BMT. Quant à la gestion de la sécurité déclarative, elle reprend d'une façon tout à fait logique ce qu'on peut trouver dans Spring Security, je pense, mais aussi [Apache Shiro](http://shiro.apache.org/) (sans les annotations, c'est vrai) : des principals, des roles, et de l'accès JAAS. Pas nouveau, c'est vrai, mais toujours pratique (car déléguant la partie pénible (création des utilisateurs, gestion des mots de passe, ...) au conteneur, enfin je pense.
10. JavaServer Faces : Oula, personnellement, je n'ai utilisé professionnellement que [Struts](http://struts.apache.org/) (même si j'ai un peu joué avec [Wicket](http://wicket.apache.org/), (G)rails). Bon, évidement, venant du Swing, quand on me parle du côté MVC de JSF avec une servlet dans le rôle du contrôleur, j'ai un léger sourire narquois, mais c'est pas grave. On découvre dans ce chapitre JSF (et ses drôles d'histoire de moteurs de rendu), et l'application d'exemple, qui vient démo
ntrer que le concept de MVC de JSf n'est pas forcément si limpide que ça, puisque le ManagedBean apparaît également comme un contrôleur (et qui montre aussi le talent d'Antonio Goncalves comme designer web :-)).
11. Pages et composants : C'est le chapitre full web du bouquin, où on évoque HTML, CSS, Javascript, JSP, des concepts qui n'ont pas changé depuis la dernière fois que j'y ai jeté un oeil (pour les trois premiers, je conseille à tout le monde d'aller sur [selfhtml](http://fr.selfhtml.org/) pour plonger dans les tripes de ces différents langages), jusques et y compris le sale mélange Java/HTML que constitue une JSP et qui justifie l'existence de [JSTL](http://adiguba.developpez.com/tutoriels/j2ee/jsp/jstl/).
12. Traitement et navigation : Ce chapitre s'attaque directement au "MVC" ou plutôt MVC2 : la FacesServlet, sa configuration et son utilisation des ManagedBean. Et honnêtement, ça donne surtout envie d'utiliser Play!, Wicket, Grails ou Gaelyk. Parce que vraiment, là, on est encore dans l'enfer XML. Pourquoi, mais pourquoi, n'y a-t-il pas de système de routage/contrôleur/vue ? Mystère ! Bon, en tout cas, pour moi, c'est clair, JSF, c'est "juste" Struts renommé, malgré toutes ses tentatives d'amélioration.
13. Envoi de messages : Fournit une bonne introduction aux MOM d'un point de vue [JMS](http://fr.wikipedia.org/wiki/Java_Message_Service), mais aussi les clés des mystérieux MDB (enfin, pour moi). Et il faut reconnaître qu'utiliser un MDB, c'est quand même vachement plus simple qu'initialiser un client JMS à la main (grâce à des annotations bien senties)
14. Services web SOAP : le pays "magique" des [WSDL](http://fr.wikipedia.org/wiki/Web_Services_Description_Language), d'[UDDI](http://fr.wikipedia.org/wiki/UDDI), et de tout un tas de mots magiques. Pour en avoir mangé, c'est pas vraiment ce que je préfère, même si manifestement, Java EE 6 apporte encore une fois une simplicité fonctionnelle énorme.
15. Services web REST : je connaissais déja un peu avec par exemple [Restlet](http://www.restlet.org/). Et c'est vrai que la pile Glassfish est très sympa.Bon, tout ça, c'est quasiment plus des avis (informés ou pas) sur les éléments de la norme, mais pas sur le bouquin. En l'occurence, il est, je trouve, très clair, et documentant correctement les différents aspects.De plus, les exemples mettent en oeuvre les différents concepts sur des cas qui, tout en étant simples, n'en sont pas moins éclairants sur les différents éléments pouvant être abordés. Qui plus est, l'utilisation de Glassfish s'avère une bonne chose, par la simplicité de mise en oeuvre des différents exemples. En effet, dans chacun de ces exemples, la seule interaction avec Glassfish est un appel à [asadmin](http://docs.sun.com/app/docs/doc/820-4497/asadmin-1m?l=en&n=1&a=view). Evidement, l'auteur aurait pu éviter ça grâce à [un quelconque plugin maven](http://stackoverflow.com/questions/1836317/which-maven-glassfish-plugin-to-use/1836691#1836691), mais ç'aurait peut-être été moins didactique, et de plus, je crois qu'il n'est pas complètement fan du "tout dans maven" (à moins que ce ne soit Emmanuel Bernard, je ne me souviens plus trop ... ah, non, Emmanuel Bernad n'aime pas les outils de builds, parce qu'avec lui, le code se builde tout seul).

En tout cas, si vous êtes francophones, que vous vous lancez dans Java EE 6, j'ai quand même l'impression que c'est le bon bouquin pour commencer. Chaque norme est abordée à la fois théoriquement et par un exemple complet, les cas d'utilisation sont clairement présentés, et les APIs raisonnablement biend écrites (ben oui, on ne va pas mettre la javadoc complète d'une interface dans un bouquin, mais plutôt une sélection des méthodes visibles). A acheter, donc.